(declare-datatypes ()
  ((list3 (nil3) (cons3 (head3 Bool) (tail3 list3)))))
(declare-datatypes () ((A (X) (Y))))
(declare-datatypes ()
  ((R (Nil)
     (Eps) (Atom (Atom_0 A)) (Plus (Plus_0 R) (Plus_1 R))
     (Seq (Seq_0 R) (Seq_1 R)) (Star (Star_0 R)))))
(declare-datatypes ()
  ((list2 (nil2) (cons2 (head2 A) (tail2 list2)))))
(declare-datatypes ()
  ((Pair (Pair2 (first list2) (second list2)))))
(declare-datatypes ()
  ((list (nil) (cons (head Pair) (tail list)))))
(declare-fun split2 (A list) list)
(declare-fun split (list2) list)
(declare-fun seq (R R) R)
(declare-fun plus (R R) R)
(declare-fun or2 (list3) Bool)
(declare-fun eqA (A A) Bool)
(declare-fun eps (R) Bool)
(declare-fun epsR (R) R)
(declare-fun step (R A) R)
(declare-fun recognise (R list2) Bool)
(declare-fun prop_RecSeq (R R list) list3)
(assert (forall ((x A)) (= (split2 x nil) nil)))
(assert
  (forall ((x A) (x2 list) (xs list2) (ys list2))
    (= (split2 x (cons (Pair2 xs ys) x2))
      (cons (Pair2 (cons2 x xs) ys) (split2 x x2)))))
(assert (= (split nil2) (cons (Pair2 nil2 nil2) nil)))
(assert
  (forall ((y A) (s list2))
    (= (split (cons2 y s))
      (cons (Pair2 nil2 (cons2 y s)) (split2 y (split s))))))
(assert
  (forall ((x R) (y R))
    (=> (distinct x Nil)
      (=> (distinct y Nil)
        (=> (distinct x Eps)
          (=> (distinct y Eps) (= (seq x y) (Seq x y))))))))
(assert
  (forall ((x R))
    (=> (distinct x Nil)
      (=> (distinct Eps Nil) (=> (distinct x Eps) (= (seq x Eps) x))))))
(assert
  (forall ((y R))
    (=> (distinct Eps Nil) (=> (distinct y Nil) (= (seq Eps y) y)))))
(assert (forall ((x R)) (=> (distinct x Nil) (= (seq x Nil) Nil))))
(assert (forall ((y R)) (= (seq Nil y) Nil)))
(assert
  (forall ((x R) (y R))
    (=> (distinct x Nil)
      (=> (distinct y Nil) (= (plus x y) (Plus x y))))))
(assert (forall ((x R)) (=> (distinct x Nil) (= (plus x Nil) x))))
(assert (forall ((y R)) (= (plus Nil y) y)))
(assert (= (or2 nil3) false))
(assert
  (forall ((y Bool) (xs list3))
    (= (or2 (cons3 y xs)) (or y (or2 xs)))))
(assert (= (eqA X X) true))
(assert (= (eqA X Y) false))
(assert (= (eqA Y X) false))
(assert (= (eqA Y Y) true))
(assert
  (forall ((x R))
    (=> (distinct x Eps)
      (=> (distinct x (Plus (Plus_0 x) (Plus_1 x)))
        (=> (distinct x (Seq (Seq_0 x) (Seq_1 x)))
          (=> (distinct x (Star (Star_0 x))) (= (eps x) false)))))))
(assert (= (eps Eps) true))
(assert
  (forall ((p R) (q R)) (= (eps (Plus p q)) (or (eps p) (eps q)))))
(assert
  (forall ((p2 R) (q2 R))
    (= (eps (Seq p2 q2)) (and (eps p2) (eps q2)))))
(assert (forall ((y R)) (= (eps (Star y)) true)))
(assert (forall ((x R)) (=> (= (eps x) true) (= (epsR x) Eps))))
(assert (forall ((x R)) (=> (= (eps x) false) (= (epsR x) Nil))))
(assert
  (forall ((x R) (y A))
    (=> (distinct x (Atom (Atom_0 x)))
      (=> (distinct x (Plus (Plus_0 x) (Plus_1 x)))
        (=> (distinct x (Seq (Seq_0 x) (Seq_1 x)))
          (=> (distinct x (Star (Star_0 x))) (= (step x y) Nil)))))))
(assert
  (forall ((y A) (a A))
    (=> (= (eqA a y) true) (= (step (Atom a) y) Eps))))
(assert
  (forall ((y A) (a A))
    (=> (= (eqA a y) false) (= (step (Atom a) y) Nil))))
(assert
  (forall ((y A) (p R) (q R))
    (= (step (Plus p q) y) (plus (step p y) (step q y)))))
(assert
  (forall ((y A) (p2 R) (q2 R))
    (= (step (Seq p2 q2) y)
      (plus (seq (step p2 y) q2) (seq (epsR p2) (step q2 y))))))
(assert
  (forall ((y A) (p3 R))
    (= (step (Star p3) y) (seq (step p3 y) (Star p3)))))
(assert (forall ((x R)) (= (recognise x nil2) (eps x))))
(assert
  (forall ((x R) (z A) (xs list2))
    (= (recognise x (cons2 z xs)) (recognise (step x z) xs))))
(assert (forall ((p R) (q R)) (= (prop_RecSeq p q nil) nil3)))
(assert
  (forall ((p R) (q R) (z list) (s1 list2) (s2 list2))
    (= (prop_RecSeq p q (cons (Pair2 s1 s2) z))
      (cons3 (and (recognise p s1) (recognise q s2))
        (prop_RecSeq p q z)))))
(assert-not
  (forall ((p R) (q R) (s list2))
    (= (recognise (Seq p q) s) (or2 (prop_RecSeq p q (split s))))))
(check-sat)
